<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="Horve的前端笔记" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>javascript - Horve的前端笔记</title><link rel="stylesheet" href="/css/main.css" type="text/css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"><a href="/">Horve的前端笔记</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/archives" class="head-nav__link">文章</a></li><li class="head-nav__item"><a href="http://weibo.com/andforce" class="head-nav__link">微博</a></li><li class="head-nav__item"><a href="https://github.com/andforce" class="head-nav__link">GitHub</a></li><li class="head-nav__item"><a href="https://bintray.com/andforce" class="head-nav__link">Bintray</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2015-11-10T09:53:31.000Z" class="post__time">November 10, 2015</time><h1 class="post__title"><a href="/2015/11/10/custom-event/">javascript自定义事件浅析</a></h1><hr/></header><div class="post__main echo"><p>在团队协作的很多情况下，某个js的函数会根据不断增加的需求进而不断增加功能，如果功能需求累积过多，我们就很难把控自己在这个函数中新定义的变量会不会覆盖掉之前的定义。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">action</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">2</span>);<span class="comment">//新增需求1</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">3</span>);<span class="comment">//新增需求2</span></span><br><span class="line">	......<span class="comment">//一直增加就很难保证下面的代码不会与之前的代码产生冲突</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而如果我们为新增的需求重新定义一个同名的js方法，那后来定义的方法又会将之前定义的方法覆盖，这当然也不是我们想要的结果。如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">action</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">action</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>);&#125;<span class="comment">//新增需求1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">action</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">3</span>);&#125;<span class="comment">//新增需求2</span></span><br></pre></td></tr></table></figure></p>
<p>执行结果：<code>3</code></p>
<p>那么有没有什么办法可以让我们的函数分别执行，并且互不影响呢？是的，你一定想到了js事件。</p>
<a id="more"></a>
<p>说到js的事件，我们立马就会想到原生js中对事件的实现。在标准DOM浏览器中的<code>addEventListener</code>、<code>removeEventListener</code>和在IE中的<code>attachEvent</code>、<code>detachEvent</code>这些已经为我们熟知，并且绑定在同一个DOM中的相同的事件彼此不会被覆盖，比如，你在某个div中绑定了3个<code>click</code>事件，在执行时它们会按序执行，而不会只执行最后一次绑定：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的例子仅实现标准DOM浏览器</span></span><br><span class="line">oDiv.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;,<span class="literal">false</span>);</span><br><span class="line">oDiv.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>);&#125;,<span class="literal">false</span>);</span><br><span class="line">oDiv.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">3</span>);&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>执行结果：1 2 3</p>
<p>看起来刚好解决了我们的各种顾虑，单独定义，互不影响，很有利于团队协作，但是这些内置的事件绑定方式却依然无法直接解决我们的问题。</p>
<p>好吧，既然无法直接解决，那我们就利用页面事件绑定的思想来自己探索，这就是我们今天要介绍的自定义事件。</p>
<p><strong> 首先来看看什么是自定义事件：让函数能够具备事件的某些特性。 </strong></p>
<p>其实自定义事件在一些主流的类库中都有实现，后续会分析具体的实现方法。今天，我们就先用简单的例子来实现自定义事件的功能。</p>
<p>回到开始的时候我们提出的需求：让函数分别执行，并且互不影响。这就好像我们要按照清单从图书馆借5本书，走出图书馆的时候，我们手里拿到的应该是想借的5本，而不是清单上的最后一本。</p>
<p>依照js的事件绑定方式来剖析一下这几本书和图书馆之间的关系：</p>
<p><img src="/images/customevent/custom-event-1.png" alt="自定义事件图示"></p>
<p>其中，图书馆就是我们要绑定事件的对象，也就是我们借书的对象，“<code>click</code>”就是我们绑定事件的类别，也就是我们想要借的书的分类，而function回调就是我们要执行的函数，也就是我们想借的具体某本书。理清了对应关系，我们就可以从一个图书馆内不同的分类书架上拿到不同的书。</p>
<p>把这个对应的关系映射到自定义事件上就是：<strong>在某个对象上绑定不同类别的一个或多个方法，并且让它们分别执行</strong>。接下来我们就来实现一下这种关系。首先来看一下自定义事件的绑定实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">on</span>(<span class="params">obj,events,fn</span>)</span>&#123;<span class="comment">//参数分别是：对象/自定义事件类别/方法</span></span><br><span class="line">	<span class="comment">//初始化自定义监听对象，如果存在继续使用，不存在就创建新对象</span></span><br><span class="line">	obj.listeners = obj.listeners || &#123;&#125;;</span><br><span class="line">	obj.listeners[events] = obj.listeners[events] || [];<span class="comment">//初始化监听的自定义事件列表</span></span><br><span class="line">	obj.listeners[events].push(fn);<span class="comment">//将要执行的方法分别存放到对应事件的列表中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就把想要执行的一系列方法绑定到了某个页面对象对应的自定义事件类别上。方法绑定好了之后，如何去触发呢？看下面的代码实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//触发</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fire</span>(<span class="params">obj,events</span>)</span>&#123;<span class="comment">//参数分别是：对象/自定义事件类别</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &amp;lt; obj.listeners[events].length; i++)&#123;<span class="comment">//遍历某个事件类别下所有的方法</span></span><br><span class="line">        obj.listeners[events][i]();<span class="comment">//依次执行遍历到的所有的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，我们定义的想要去执行的每个方法都能被执行，并且它们之间互不影响。看个实际的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eventHandle = &#123;</span><br><span class="line">	on: <span class="function"><span class="keyword">function</span>(<span class="params">obj,events,fn</span>)</span>&#123;</span><br><span class="line">		obj.listeners = obj.listeners || &#123;&#125;;</span><br><span class="line">		obj.listeners[events] = obj.listeners[events] || [];</span><br><span class="line">		obj.listeners[events].push(fn);</span><br><span class="line">	&#125;,</span><br><span class="line">	fire: <span class="function"><span class="keyword">function</span>(<span class="params">obj,events</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, n = obj.listeners[events].length; i &amp;lt; n; i++)&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(obj.listeners[events]);</span><br><span class="line">			obj.listeners[events][i] &amp;&amp; obj.listeners[events][i]();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	off: <span class="function"><span class="keyword">function</span>(<span class="params">obj,events</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, n = obj.listeners[events].length; i &amp;lt; n; i++)&#123;</span><br><span class="line">			obj.listeners[events][i] = <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定自定义事件，</span></span><br><span class="line">eventHandle.on(oDiv,<span class="string">"eventType1"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;);<span class="comment">//准备执行方法1</span></span><br><span class="line">eventHandle.on(oDiv,<span class="string">"eventType1"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>);&#125;);<span class="comment">//准备执行方法2</span></span><br><span class="line">eventHandle.on(oDiv,<span class="string">"eventType1"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">3</span>);&#125;);<span class="comment">//准备执行方法3</span></span><br><span class="line">eventHandle.on(oDiv,<span class="string">"eventType2"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">4</span>);&#125;);<span class="comment">//准备执行方法4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//触发执行</span></span><br><span class="line">eventHandle.fire(oDiv,<span class="string">"eventType1"</span>);<span class="comment">//执行eventType1下的所有方法</span></span><br></pre></td></tr></table></figure>
<p>执行结果：1 2 3</p>
<p>不执行方法4是因为，eventType2下的方法4仅仅被绑定，并没有被触发。</p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/event/" class="post__tag__link">event</a></li><li class="post__tag__item"><a href="/tags/自定义事件/" class="post__tag__link">自定义事件</a></li></ul><a class="post__foot-link u-fr"></a></footer></article></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2016 Horve<bdi> Theme by <a href="https://github.com/andforce/hexo-theme-andforce" >andforce</a></bdi></div><menu class="page-menu u-fr"><li class="page-menu__item"><span title="Previous" class="page-menu__link icon-arrow-left page-menu__link--disabled"></span></li><li class="page-menu__item"><span title="Next" class="page-menu__link icon-arrow-right page-menu__link--disabled"></span></li></menu></footer></body></html>
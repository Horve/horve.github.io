<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="Horve的前端笔记" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>原创 - Horve的前端笔记</title><link rel="stylesheet" href="/css/main.css" type="text/css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"><a href="/">Horve的前端笔记</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/archives" class="head-nav__link">文章</a></li><li class="head-nav__item"><a href="http://weibo.com/andforce" class="head-nav__link">微博</a></li><li class="head-nav__item"><a href="https://github.com/andforce" class="head-nav__link">GitHub</a></li><li class="head-nav__item"><a href="https://bintray.com/andforce" class="head-nav__link">Bintray</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2015-10-16T16:06:12.000Z" class="post__time">October 17, 2015</time><h1 class="post__title"><a href="/2015/10/17/chrome-extension/">chrome拓展开发实战：页面脚本的拦截注入</a></h1><hr/></header><div class="post__main echo"><p>目前公司产品的无线站点已经实现了业务平台组件化，所有业务组件的转场都是通过路由来完成，而各个模块是通过requirejs进行统一管理，在灰度测试时会通过grunt进行打包操作，虽然工程化的开发流程已经大大提升了效率，但是为了满足不同平台在任意业务入口页面一键注入业务脚本即可进行测试的实际需求，团队尝试通过chrome拓展来进行实现。由于我本人是第一次开发chrome拓展插件，所以开发的过程中遇到不少坑，某些功能的实现方式也未必是最好，但还是有很多难得的收获。接下来就围绕“拦截与注入”的功能点，详细介绍一下开发过程。<br><a id="more"></a></p>
<p>首先来看一看开发完成后的组件界面：</p>
<p><img src="/images/chrome/chrome-1.jpg" alt="1"></p>
<h2 id="拓展的主要功能点：">拓展的主要功能点：</h2><blockquote>
<p>1，页面脚本的嗅探<br>2，指定脚本的下载<br>3，指定域名下脚本的自动拦截（加载时不执行）<br>4，普通方式直接向页面中注入脚本<br>5，通过requirejs向页面注入脚本<br>6，拦截指定域名下资源后弹出通知窗口</p>
</blockquote>
<p>在正式开始开发上述功能点之前，还是有必要先对chrome拓展的相关概念进行介绍。</p>
<h2 id="关于chrome拓展">关于chrome拓展</h2><p>chrome拓展可以大大的扩展你的浏览器的功能。包括但不仅限于这些功能：捕捉特定网页的内容，捕捉HTTP报文，捕捉用户浏览动作，改变浏览器地址栏/起始页/书签/Tab等界面元素的行为，与别的站点通信，修改网页内容……不过，浏览器插件也有一定的弊端，那就是会带来一些安全隐患，也可能让你的浏览器变得缓慢甚至不稳定。</p>
<p>开始开发chrome拓展的时候，你几乎不需要准备任何东西，只需要一个编辑器，然后准备好API文档随时查阅即可。关于如何开始一个chrome拓展，官方有一篇文章介绍，文章不是特别长，但足够你了解一个chrome拓展是如何产生的。官方的DEMO中一共有4个文件：</p>
<ul>
<li><code>manifest.json</code> - 所有插件都要有这个文件，这是插件的配置文件，可看作插件的“入口”。</li>
<li><code>icon.png</code> - 拓展的小图标，推荐使用19*19的半透明png图片，也就是上图中拓展的入口小图标。</li>
<li><code>popup.html</code> - 就是你看到的打开拓展后的界面。</li>
<li><code>popup.js</code> - 拓展界面引用的js文件。</li>
</ul>
<p><code>manifest.json</code>作为配置文件，在拓展中是核心文件，内容也非常显而易见：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"One-click Kittens"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"This extension demonstrates a browser action with kittens."</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0"</span>,</span><br><span class="line">  <span class="string">"permissions"</span>: [</span><br><span class="line">    <span class="string">"https://secure.flickr.com/"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"browser_action"</span>: &#123;</span><br><span class="line">    <span class="string">"default_icon"</span>: <span class="string">"icon.png"</span>,</span><br><span class="line">    <span class="string">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>manifest_version</code>：现在应该总是2。</p>
<p><code>permissions</code>：很重要的东西，即允许插件做哪些事情，访问哪些站点，假如一个插件的”permissions”里写有<code>http://*.hacker.com</code>，那么这个插件就被允许访hacker.com上的所有内容，包括可能会把你的一些个人信息提交给hacker.com，危险性不言而喻，查看一个插件能访问那些站点的方法是：在chrome的地址栏里输入<code>chrome://extensions/</code>，然后点对应插件的旁边的那个“权限”。</p>
<p><code>default_popup</code>：用来指定点击小图标后弹出的小窗口中默认显示的是哪个html，这个弹出的小窗口就叫做“popup”。</p>
<p><code>browser_action</code>：这是一个浏览器级的动作，也就是说，不管你现在在访问哪个页面，那个小按钮总是显示出来，而我们的插件如果仅仅是针对某些页面的话，就不适合用这个”browser_action”了，而要用”page_action”，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="string">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line">     <span class="string">"name"</span>: <span class="string">"ihorve.com viewer"</span>,</span><br><span class="line">     <span class="string">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">     <span class="string">"background"</span>: &#123; <span class="string">"scripts"</span>: [<span class="string">"background.js"</span>] &#125;,</span><br><span class="line">     <span class="string">"permissions"</span>: [<span class="string">"tabs"</span>],</span><br><span class="line">     <span class="string">"page_action"</span>: &#123;</span><br><span class="line">          <span class="string">"default_icon"</span>: &#123;</span><br><span class="line">               <span class="string">"19"</span>: <span class="string">"ihorve_19.png"</span>,</span><br><span class="line">               <span class="string">"38"</span>: <span class="string">"ihorve_38.png"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">"default_title"</span>: <span class="string">"ihorve.com article information"</span>,</span><br><span class="line">          <span class="string">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Page Actions</code>与<code>Browser Actions</code>非常类似，除了Page Actions没有badge外，其他Browser Actions所有的方法Page Actions都有。另外的区别就是，Page Actions并不像Browser Actions那样一直显示图标，而是可以在特定标签特定情况下显示或隐藏，所以它还具有独有的show和hide方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrome.pageAction.show(integer tabId);</span><br><span class="line">chrome.pageAction.hide(integer tabId);</span><br></pre></td></tr></table></figure>
<p><code>tabId</code>为标签id，可以通过tabs接口获取，有关tab相关的内容将在后面进行讲解。</p>
<p>在<code>page_action</code>中，“<code>permissions</code>”属性里的“<code>tabs</code>”是必须的，否则下面的js不能获取到tab里的url，而这个url是我们判断是否要把小图标show出来的依据。这样，拓展小图标只会在指定url被打开时出现在地址栏里。</p>
<p>关于拓展的组成文件，可以参考360翻译成中文的<a href="http://open.chrome.360.cn/extension_dev/overview.html" target="_blank" rel="external">官方文档</a>，很好理解，这里不再赘述，有些不好理解的就是拓展中消息的传递，也就是如何通过拓展界面与页面进行通信，在涉及到的地方我会进行详细说明。接下来我们就围绕相关的功能点介绍对应的API及实现过程。我的拓展包中的主要文件如下：</p>
<ul>
<li>manifest.json - 同上</li>
<li>icon.png - 拓展的小图标</li>
<li>popup.html - 拓展界面html</li>
<li>popup.js - 拓展界面引用的js文件</li>
<li>returnjs.js - 拦截页面脚本时，阻止页面脚本执行的注入脚本</li>
<li>sendlink.js - 嗅探页面脚本时的注入脚本</li>
<li>background.js - chrome拓展的主程序</li>
</ul>
<p>在这里先介绍一下<code>background.js</code>。<code>background</code>是什么概念？这是一个很重要的东西，可以把它认为是chrome插件的主程序，理解这个很关键，一旦插件被启用（有些插件对所有页面都启用，有些则只对某些页面启用），chrome就给插件开辟了一个独立的javascript运行环境（又称作运行上下文），用来跑你指定的background script，在这个例子中，也就是background.js。在background.js中，可以指定插件要立即执行的任务，以及配置在哪些域名中要立即执行这些任务。</p>
<p><code>background.js</code>通过<code>manifest.json</code>文件中的<code>background</code>配置项进行指定：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"background"</span>: &#123;</span><br><span class="line">    <span class="string">"scripts"</span>: [<span class="string">"background.js"</span>]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="页面脚本的嗅探">页面脚本的嗅探</h2><p>嗅探页面脚本的流程大概是：</p>
<ul>
<li>1，获取当前打开的标签</li>
<li>2，向当前标签注入脚本sendlink.js（在当前标签的页面中执行，收集页面外链脚本并向拓展发送获取到的脚本列表）</li>
<li>3，拓展中监听当前页面发送的脚本列表并展现</li>
</ul>
<p>上述流程都在popup.js文件中实现。首先来看如何获取当前打开的标签，以及如何向当前标签注入一个<code>sendlink.js</code>文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">chrome.windows.getCurrent(<span class="function"><span class="keyword">function</span>(<span class="params"> currentWindow </span>) </span>&#123;</span><br><span class="line">  <span class="comment">//获取有指定属性的标签，为空获取全部标签</span></span><br><span class="line">  chrome.tabs.query( &#123;</span><br><span class="line">    active: <span class="literal">true</span>, windowId: currentWindow.id</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">activeTabs</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"TabId:"</span> + activeTabs[<span class="number">0</span>].id);</span><br><span class="line">    <span class="comment">//执行注入，第一个参数表示向哪个标签注入</span></span><br><span class="line">    <span class="comment">//第二个参数是一个option对象，file表示要注入的文件，也可以是code</span></span><br><span class="line">    <span class="comment">//是code时，对应的值为要执行的js脚本内容，如：code: "alert(1);"</span></span><br><span class="line">    <span class="comment">//allFrames表示如果页面中有iframe，是否也向iframe中注入脚本</span></span><br><span class="line">    chrome.tabs.executeScript(activeTabs[<span class="number">0</span>].id, &#123;</span><br><span class="line">      file: <span class="string">"sendlink.js"</span>,</span><br><span class="line">      allFrames: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>获取当前打开标签和向标签中注入脚本文件的操作都已经完成，现在我们来看一看sendlink.js文件中的具体内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> links = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"script"</span>),</span><br><span class="line">    arr = [];</span><br><span class="line">[].forEach.call(links, <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> href = el.src;</span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/[http|https]:\/\//gi</span>.test(href))&#123;</span><br><span class="line">    arr.push(href);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">arr.sort();</span><br><span class="line"><span class="comment">//向拓展发送消息，这里就涉及到了消息通讯</span></span><br><span class="line">chrome.extension.sendMessage(arr);</span><br></pre></td></tr></table></figure>
<p>上述代码中出现了消息通讯，如果你仅仅需要给你自己的扩展的另外一部分发送一个消息（可选的是否得到答复），你可以简单地使用<code>chrome.extension.sendMessage()</code>方法。这个方法可以帮助你从当前的标签页面到扩展传送一次JSON序列化消息。</p>
<p>而在拓展中，可以使用<code>chrome.extension.onMessage()</code>方法进行监听，并且在回调中处理监听到的消息内容。详情请查阅360翻译的中文文档。文档中的<code>chrome.extension.sendRequest()</code>和<code>chrome.extension.sendRequest()</code>已经被更新的<code>onMessage</code>和<code>sendMessage</code>代替。下面就来看一看在<code>popup.js</code>中如何监听消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chrome.extension.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">links</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//处理接收到的links，展现在拓展页面中的DOM里</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样就完成了一次从拓展向当前标签页注入脚本，在注入的脚本中收集script外链脚本，并且将脚本列表通过消息发送给拓展，然后在拓展中接收并处理消息的过程。</p>
<h2 id="指定脚本的下载">指定脚本的下载</h2><p>下载功能就相对简单，使用chrome拓展的downloads API即可。因为下载功能是在拓展中实现的，所以js脚本应该写在popup.js文件中。此外，下载功能需要在<code>manifest.json</code>文件中配置<code>permissions</code>，增加<code>downloads</code>权限：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"permissions"</span>: [<span class="string">"downloads"</span>],</span><br><span class="line">执行下载链接的逻辑。应该在按钮的点击事件后执行。</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载所选链接</span></span><br><span class="line">downloadLinks: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, n = MainLogic.visibleLinks.length; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (MainLogic.$id(<span class="string">"cb"</span> + i).checked)&#123;</span><br><span class="line">      <span class="comment">//chrome拓展的下载API</span></span><br><span class="line">      chrome.downloads.download(&#123;url: MainLogic.visibleLinks[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指定域名下脚本的自动拦截">指定域名下脚本的自动拦截</h2><p>资源拦截的功能需要为<code>manfest.json</code>中的<code>permissions</code>字段配置<code>webRequest</code>和<code>webRequestBlocking</code>权限。而进行资源拦截的原理也很容易从这两个词的意思上看出来：在web发送请求的时候执行操作。其实webRequest的核心意思就是要伪造各种request，那么就不单单是写某个对象的数据这么简单，还需要选择合适的时机，在发送某种request之前伪造好它，或者在真实的request到来之后半路截获它，替换成假的然后再发出去。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"permissions"</span>: [</span><br><span class="line">    <span class="string">"webRequest"</span>, </span><br><span class="line">    <span class="string">"webRequestBlocking"</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>Chrome提供了较为完整的方法供扩展程序分析、阻断及更改网络请求，同时也提供了一系列较为全面的监听事件以监听整个网络请求生命周期的各个阶段。网络请求的整个生命周期所触发事件的时间顺序如下图所示。</p>
<p><img src="/images/chrome/chrome-2.jpg" alt="2"></p>
<p>因为我们需要在指定的域名的资源开始发送请求的时候就进行拦截，所以不能等到拓展打开的时候才去执行拦截操作，必须在页面一打开就进行拦截的部署，因此拦截的逻辑应该放在background.js中，而非popup.js中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听发送请求</span></span><br><span class="line">chrome.webRequest.onBeforeRequest.addListener(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">details</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(details);</span><br><span class="line">    <span class="comment">//拦截到执行资源后，为资源进行重定向</span></span><br><span class="line">    <span class="comment">//也就是是只要请求的资源匹配拦截规则，就转而执行returnjs.js</span></span><br><span class="line">    <span class="keyword">return</span> &#123;redirectUrl: chrome.extension.getURL(<span class="string">"returnjs.js"</span>)&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//配置拦截匹配的url，数组里域名下的资源都将被拦截</span></span><br><span class="line">    urls: [</span><br><span class="line">        <span class="string">"*://*.jquery.top/*"</span>,</span><br><span class="line">        <span class="string">"*://*.elongstatic.com/*"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">//拦截的资源类型，在这里只拦截script脚本，也可以拦截image等其他静态资源</span></span><br><span class="line">    types: [<span class="string">"script"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//要执行的操作，这里配置为阻断</span></span><br><span class="line">  [<span class="string">"blocking"</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在这里，拦截资源我们用到了一个监听事件：<code>chrome.webRequest.onBeforeRequest.addListener()</code>，只要有匹配域名下的资源将要发送请求，就立即执行回调：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chrome.webRequest.onBeforeRequest.addListener(</span><br><span class="line">    callback, filter, opt_extraInfoSpec</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>回调函数所接收到的信息对象均包括如下属性：<code>requestId</code>、<code>url</code>、<code>method</code>、<code>frameId</code>、<code>parentFrameId</code>、<code>tabId</code>、<code>type</code>和<code>timeStamp</code>。其中type可能的值包括<code>main_frame</code>、<code>sub_frame</code>、<code>stylesheet</code>、<code>script</code>、<code>image</code>、<code>object</code>、<code>xmlhttprequest</code>和<code>other</code>。</p>
<h2 id="拦截指定域名下资源后弹出通知窗口">拦截指定域名下资源后弹出通知窗口</h2><p>在拦截到指定资源后，比较好的体验是告诉用户页面资源已被拦截，这样就可以使用chrome的通知接口向用户发出通知。<code>chrome.notifications.create()</code>可以帮我们做到向用户发出浏览器通知。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弹出通知</span></span><br><span class="line">chrome.notifications.clear(<span class="string">"newNotice"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> wasClear </span>) </span>&#123;</span><br><span class="line">    chrome.notifications.create(<span class="string">"newNotice"</span>, &#123;</span><br><span class="line">    type: <span class="string">"basic"</span>,</span><br><span class="line">    iconUrl: chrome.runtime.getURL(<span class="string">"images/logo.png"</span>),</span><br><span class="line">    title: <span class="string">"页面JS拦截提醒"</span>,</span><br><span class="line">    message: <span class="string">"拓展将开启页面JS拦截，若要恢复js执行请关闭拓展。"</span></span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"> notificationId </span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(notificationId);</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>chrome通知的API介绍，请阅读这篇文章：<a href="http://www.ihorve.com/?p=488" target="_blank" rel="external">Chrome插件桌面通知API的变化</a>。</p>
<h2 id="普通方式注入js脚本">普通方式注入js脚本</h2><p>脚本的注入在前文已经介绍过，就是将指定的脚本资源在合适的时机放到页面中执行。在这里，我需要在拓展中输入远程脚本URL，在点击注入按钮后向页面注入，基本逻辑也很简单，就是通过ajax发送请求，在responseText返回时，将返回的脚本作为code注入到页面里。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取远程脚本并进行普通注入</span></span><br><span class="line">  getScript: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    MainLogic.setInjectUrl();</span><br><span class="line">    <span class="keyword">var</span> url = MainLogic.injecturl;</span><br><span class="line">    <span class="keyword">if</span>( url ) &#123;</span><br><span class="line">      $(<span class="string">"#injectValue"</span>).removeClass(<span class="string">"errbox"</span>);</span><br><span class="line">      <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">      xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> code = xhr.responseText;</span><br><span class="line">            <span class="built_in">console</span>.log(code);</span><br><span class="line">            <span class="comment">//第一个参数为null时，表示注入的目标是当前打开的tab</span></span><br><span class="line">            <span class="comment">//获取到返回值时，通过code注入到页面中，在回调中打印注入成功的提示</span></span><br><span class="line">            chrome.tabs.executeScript(<span class="literal">null</span>, &#123;code: code, allFrames: <span class="literal">false</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">"executeScript success!!!!!!!!!"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $(<span class="string">'#xhr-errbox'</span>).show();</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">              $(<span class="string">'#xhr-errbox'</span>).hide();</span><br><span class="line">            &#125;, <span class="number">2000</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> ts = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">      <span class="keyword">var</span> u;</span><br><span class="line">      <span class="keyword">if</span>(url.indexOf(<span class="string">'?'</span>) === -<span class="number">1</span>)&#123;</span><br><span class="line">        u = url + <span class="string">'?_t='</span> + ts;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        u = url + <span class="string">'&amp;_t='</span> + ts;</span><br><span class="line">      &#125;</span><br><span class="line">      xhr.open(<span class="string">'GET'</span>,u,<span class="literal">true</span>);</span><br><span class="line">      xhr.send(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      $(<span class="string">"#injectValue"</span>).addClass(<span class="string">"errbox"</span>);</span><br><span class="line">      MainLogic.msgBox(<span class="string">"远程脚本不能为空！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>上述提到的注入方式中，注入时机是响应操作后进行注入，还有一种方式是通过内容脚本的方式如，也就是<code>content script</code>。这种方式需要在<code>manifest.json</code>中进行配置，即在拓展有访问权限的页面打开时立即向页面注入资源。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"content_scripts"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"matches"</span>: [<span class="string">"http://*/*"</span>],<span class="comment">//匹配url</span></span><br><span class="line">        <span class="string">"js"</span>: [<span class="string">"jquery-1.9.1.js"</span>],<span class="comment">//向匹配url中注入指定脚本</span></span><br><span class="line">                <span class="string">"css"</span>: [<span class="string">"css.css"</span>],<span class="comment">//向匹配url中注入css样式</span></span><br><span class="line">        <span class="string">"run_at"</span>: <span class="string">"document_end"</span><span class="comment">//注入时机，这里是在document节点加载完成时注入</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>具体的配置可参见360翻译的中文API文档。</p>
<h2 id="通过requirejs向页面注入脚本">通过requirejs向页面注入脚本</h2><p>通过requirejs向页面注入脚本比普通方式稍有特殊，因为requirejs的执行需要在页面中引入require.js，并在data-main属性中配置入口脚本，所以使用普通方式注入显然不符合实际，这里的解决方案就是，在domready后向页面通过document.write的方式注入脚本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行注入requirejs</span></span><br><span class="line">  injectRequire: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    MainLogic.setInjectUrl();</span><br><span class="line">    <span class="comment">//require.js打在拓展包中，通过chrome.extension.getURL来获取资源路径</span></span><br><span class="line">    <span class="keyword">var</span> requireurl = chrome.extension.getURL(<span class="string">"require.js"</span>);</span><br><span class="line">    <span class="keyword">var</span> datamainjs = MainLogic.injecturl;</span><br><span class="line">    <span class="keyword">if</span>( datamainjs ) &#123;</span><br><span class="line">      <span class="keyword">var</span> executeCode = <span class="string">''</span> +</span><br><span class="line">        <span class="string">'var scripts = document.getElementsByTagName("script");'</span> +</span><br><span class="line">        <span class="string">'[].forEach.call(scripts, function(script) &#123;'</span> +</span><br><span class="line">        <span class="string">'  if(!!script.src &amp;&amp; script.src == "'</span> + requireurl + <span class="string">'")&#123;'</span> +</span><br><span class="line">        <span class="string">'    script.parentNode.removeChild(script);'</span> +</span><br><span class="line">        <span class="string">'  &#125;'</span> +</span><br><span class="line">        <span class="string">'&#125;);'</span> +</span><br><span class="line">        <span class="string">'var Req_script = document.createElement("script");'</span> +</span><br><span class="line">        <span class="string">'Req_script.src = "'</span> + requireurl + <span class="string">'";'</span> +</span><br><span class="line">        <span class="string">'Req_script.setAttribute("data-main","'</span> + datamainjs + <span class="string">'");'</span> +</span><br><span class="line">        <span class="string">'document.body.appendChild(Req_script);'</span>;</span><br><span class="line">      chrome.tabs.executeScript(<span class="literal">null</span>, &#123;</span><br><span class="line">        code: executeCode</span><br><span class="line">      &#125;);</span><br><span class="line">      MainLogic.msgBox(<span class="string">"已成功注入！"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      $(<span class="string">"#injectValue"</span>).addClass(<span class="string">"errbox"</span>);</span><br><span class="line">      MainLogic.msgBox(<span class="string">"远程脚本不能为空！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>从那个面的代码中可以看出，首先需要将拓展包内的资源路径取出，然后将要注入的脚本内容拼接成字符串，最后进行执行。这里还有一个问题，就是通过<code>chrome.extension.getURL</code>来获取包内资源的路径。在获取路径的时候，需要通过manifest.json文件中的的<code>web_accessible_resources</code>属性为资源配置访问权限。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"web_accessible_resources"</span>: [</span><br><span class="line">    <span class="string">"require.js"</span>,</span><br><span class="line">    <span class="string">"returnjs.js"</span>,</span><br><span class="line">    <span class="string">"images/*"</span> <span class="comment">//images目录下的所有资源，拓展都将有权访问</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="测试你的chrome拓展">测试你的chrome拓展</h2><p>因为在正式上线到chrome拓展托管平台需要将拓展包打包成.crx格式的文件，所以我们刚才所做的一切都只是开发版，那开发版如何测试呢？其实非常简单，你只需要在Chrome浏览器中打开chrome://extensions/，点击“加载已解压的拓展程序”，选中你的拓展开发目录，拓展小图标就出来了。当你拓展的代码有更改时，记得点一下“重新加载”按钮，重新加载你的拓展程序，以保证你能看到的拓展是最新的版本。</p>
<p><img src="/images/chrome/chrome-3.jpg" alt="3"></p>
<p>里面的“权限”就是你在manifest.json文件的permissions中配置的url。</p>
<p>到这里，开发流程和功能点相关的API都已介绍完毕，整体来说开发一个chrome拓展并不复杂，只要找到对应的API，然后理清background.js和拓展页面js以及要注入到标签页面中的js之间的逻辑关系，并且知道如何通过监听事件互相发送和接受消息，一个满足你不同需求的chrome拓展就很容易开发出来。因博主也是第一次接触chrome拓展开发，如果在文章中有地方描述有误，欢迎在评论中指出。也希望本文的分享能为大家带来一些解决问题的思路。</p>
<p>项目源码已经开放到github：<a href="https://github.com/Horve/js-inject" target="_blank" rel="external">点击这里</a>，欢迎各种fork star~</p>
<h2 id="外部API资源文档">外部API资源文档</h2><p>360极速浏览器开放平台（chrome官方API的中文版本，但不是最新）： <a href="http://open.chrome.360.cn/extension_dev/overview.html" target="_blank" rel="external">http://open.chrome.360.cn/extension_dev/overview.html</a></p>
<p>chrome插件中文开发文档（非官方，与官方文档一致，不用翻墙）： <a href="http://chrome.liuyixi.com/overview.html" target="_blank" rel="external">http://chrome.liuyixi.com/overview.html</a></p>
<p>Chrome扩展及应用开发（电子书）： <a href="http://www.ituring.com.cn/book/1472" target="_blank" rel="external">http://www.ituring.com.cn/book/1472</a></p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/chrome/" class="post__tag__link">chrome</a></li><li class="post__tag__item"><a href="/tags/chrome拓展/" class="post__tag__link">chrome拓展</a></li><li class="post__tag__item"><a href="/tags/原创/" class="post__tag__link">原创</a></li></ul><a class="post__foot-link u-fr"></a></footer></article><article class="post"><header class="post__head"><time datetime="2015-09-14T12:15:31.000Z" class="post__time">September 14, 2015</time><h1 class="post__title"><a href="/2015/09/14/performanceAPI/">使用性能API快速分析web前端性能</a></h1><hr/></header><div class="post__main echo"><p>页面的性能问题一直是产品开发过程中的重要一环，很多公司也一直在使用各种方式监控产品的页面性能。从控制台工具、Fiddler抓包工具，到使用<code>DOMContentLoaded</code>和<code>document.onreadystatechange</code>这种侵入式javascript代码方式来检测DOM事件发生和结束的时间，再到使用第三方工具如<code>WebPagetest</code>、<code>Pingdom</code>等通过在不同的浏览器环境和地域进行测试来寻求优化建议等等，这些方式不仅麻烦，而且测量的指标比较单一。如果有一些可以帮我们直接获取页面性能信息的API出现，并且成为标准被被浏览器厂商支持，那性能监控会不会又是另一幅蓝图？</p>
<a id="more"></a>
<p>好在W3C Web性能工作小组与各浏览器厂商都已认识到性能对于web开发的重要性，为了解决当前性能测试的困难，W3C推出了一套性能API标准，各种浏览器对这套标准的支持如今也逐渐成熟起来。这套API的目的是简化开发者对网站性能进行精确分析与控制的过程，方便开发者采取手段提高web性能。</p>
<p>整套标准包含了10余种API，各自针对性能检测的某个方面。在下图中可以看到它们当前在规范流程中的进展：</p>
<p><img src="/images/performance/1.png" alt="API进展"></p>
<h2 id="下面是API及描述其功能的列表：">下面是API及描述其功能的列表：</h2><table>
<thead>
<tr>
<th style="text-align:left">API</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Navigation Timing</td>
<td style="text-align:left">导航计时</td>
<td style="text-align:left">能够帮助网站开发者检测真实用户数据（RUM），例如带宽、延迟或主页的整体页面加载时间。</td>
</tr>
<tr>
<td style="text-align:left">Resource Timing</td>
<td style="text-align:left">资源计时</td>
<td style="text-align:left">对单个资源的计时，可以对细粒度的用户体验进行检测。</td>
</tr>
<tr>
<td style="text-align:left">High Resolution Timing</td>
<td style="text-align:left">高精度计时</td>
<td style="text-align:left">该API规范所定义的JavaScript接口能够提供精确到微秒级的当前时间，并且不会受到系统时钟偏差或调整的影响。</td>
</tr>
<tr>
<td style="text-align:left">Page Visibility</td>
<td style="text-align:left">页面可见性</td>
<td style="text-align:left">通过这一规范，网站开发者能够以编程方式确定页面的当前可见状态，从而使网站能够更有效地利用电源与CPU。当页面获得或失去焦点时，文档对象的visibilitychange事件便会被触发。</td>
</tr>
<tr>
<td style="text-align:left">Performance Timeline</td>
<td style="text-align:left">性能时间线</td>
<td style="text-align:left">以一个统一的接口获取由Navigation Timing、Resourcing Timing和User Timing所收集的性能数据。</td>
</tr>
<tr>
<td style="text-align:left">Battery Status</td>
<td style="text-align:left">电池状态</td>
<td style="text-align:left">能够检测当前设备的电池状态，例如是否正在充电、电量等级。可以根据当前电量决定是否显示某些内容，对于移动设备来说非常实用。</td>
</tr>
<tr>
<td style="text-align:left">User Timing</td>
<td style="text-align:left">用户计时</td>
<td style="text-align:left">可以对某段代码、函数进行自定义计时，以了解这段代码的具体运行时间。</td>
</tr>
<tr>
<td style="text-align:left">Beacon</td>
<td style="text-align:left">灯塔</td>
<td style="text-align:left">可以将分析结果或诊断代码发送给服务器，它采用了异步执行的方式，因此不会影响页面中其它代码的运行。</td>
</tr>
<tr>
<td style="text-align:left">Animation Timing</td>
<td style="text-align:left">动画计时</td>
<td style="text-align:left">通过requestAnimationFrame函数让浏览器精通地控制动画的帧数，能够有效地配合显示器的刷新率，提供更平滑的动画效果，减少对CPU和电池的消耗。</td>
</tr>
<tr>
<td style="text-align:left">Resource Hits</td>
<td style="text-align:left">资源提示</td>
<td style="text-align:left">通过html属性指定资源的预加载，例如在浏览相册时能够预先加载下一张图片，加快翻页的显示速度。</td>
</tr>
<tr>
<td style="text-align:left">Frame Timing</td>
<td style="text-align:left">帧计时</td>
<td style="text-align:left">通过一个接口获取与帧相关的性能数据，例如每秒帧数和TTF。</td>
</tr>
<tr>
<td style="text-align:left">Navigation Error Logging</td>
<td style="text-align:left">错误日志记录</td>
<td style="text-align:left">通过一个接口存储及获取与某个文档相关的错误记录。</td>
</tr>
</tbody>
</table>
<h2 id="浏览器支持">浏览器支持</h2><p>下表列举了当前主流浏览器对性能API的支持，其中标注星号的内容并非来自于Web性能工作小组。</p>
<table>
<thead>
<tr>
<th style="text-align:left">规范</th>
<th style="text-align:center">IE</th>
<th style="text-align:center">Firefox</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Safari</th>
<th style="text-align:center">Opera</th>
<th style="text-align:center">iOS Safari</th>
<th style="text-align:center">Android</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Navigation Timing</td>
<td style="text-align:center">9</td>
<td style="text-align:center">31</td>
<td style="text-align:center">全部</td>
<td style="text-align:center">8</td>
<td style="text-align:center">26</td>
<td style="text-align:center">8 (不包括 8.1)</td>
<td style="text-align:center">4.1</td>
</tr>
<tr>
<td style="text-align:left">High Resolution Timing</td>
<td style="text-align:center">10</td>
<td style="text-align:center">31</td>
<td style="text-align:center">全部</td>
<td style="text-align:center">8</td>
<td style="text-align:center">26</td>
<td style="text-align:center">8 (不包括 8.1)</td>
<td style="text-align:center">4.4</td>
</tr>
<tr>
<td style="text-align:left">Page Visibility</td>
<td style="text-align:center">10</td>
<td style="text-align:center">31</td>
<td style="text-align:center">全部</td>
<td style="text-align:center">7</td>
<td style="text-align:center">26</td>
<td style="text-align:center">7.1</td>
<td style="text-align:center">4.4</td>
</tr>
<tr>
<td style="text-align:left">Resource Timing</td>
<td style="text-align:center">10</td>
<td style="text-align:center">34</td>
<td style="text-align:center">全部</td>
<td style="text-align:center">-</td>
<td style="text-align:center">26</td>
<td style="text-align:center">-</td>
<td style="text-align:center">4.4</td>
</tr>
<tr>
<td style="text-align:left">Battery Status*</td>
<td style="text-align:center">-</td>
<td style="text-align:center">31（部分支持）</td>
<td style="text-align:center">38</td>
<td style="text-align:center">-</td>
<td style="text-align:center">26</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">User Timing</td>
<td style="text-align:center">10</td>
<td style="text-align:center">-</td>
<td style="text-align:center">全部</td>
<td style="text-align:center">-</td>
<td style="text-align:center">26</td>
<td style="text-align:center">-</td>
<td style="text-align:center">4.4</td>
</tr>
<tr>
<td style="text-align:left">Beacon</td>
<td style="text-align:center">-</td>
<td style="text-align:center">31</td>
<td style="text-align:center">39</td>
<td style="text-align:center">-</td>
<td style="text-align:center">26</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">Animation Timing</td>
<td style="text-align:center">10</td>
<td style="text-align:center">31</td>
<td style="text-align:center">全部</td>
<td style="text-align:center">6.1</td>
<td style="text-align:center">26</td>
<td style="text-align:center">7.1</td>
<td style="text-align:center">4.4</td>
</tr>
<tr>
<td style="text-align:left">Resource Hints</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">仅限Canary版</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">Frame Timing</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">Navigation Error Logging</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">WebP*</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">全部</td>
<td style="text-align:center">-</td>
<td style="text-align:center">26</td>
<td style="text-align:center">-</td>
<td style="text-align:center">4.1</td>
</tr>
<tr>
<td style="text-align:left">Picture element and srcset attribute *</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">38</td>
<td style="text-align:center">-</td>
<td style="text-align:center">26</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>其中有两个可以帮助我们检测真实用户环境下的页面加载Timing和页面资源加载Timing: <code>Navigation Timing</code>和<code>Resource Timing</code>。这两个API非常有用，可以帮助我们获取页面的Domready时间、onload时间、白屏时间等，以及单个页面资源在从发送请求到获取到rsponse各阶段的性能参数。</p>
<p>使用这两个API时需要在页面完全加载完成之后才能使用，最简单的办法是在window.onload事件中读取各种数据，因为很多值必须在页面完全加载之后才能得出。</p>
<h2 id="Navigation_Timing">Navigation Timing</h2><p><code>Navigation Timing API</code>能够帮助网站开发者检测真实用户数据（RUM），例如带宽、延迟或主页的整体页面加载时间。用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timinhObj = performance.timing;</span><br></pre></td></tr></table></figure>
<p><code>performance.timing</code>返回的是一个<code>PerformanceTiming</code>对象，如下图：</p>
<p><img src="/images/performance/performancetiming01.png" alt="PerformanceTiming"></p>
<p>如果要获得 page load time(页面加载时间)，可以用<code>PerformanceTiming</code>对象中<code>loadEventStart</code>的值减去<code>navigationStart</code>的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt = page.loadEventStart - page.navigationStart;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>PerformanceTiming</code>对象中各属性值的单位均为毫秒数。</p>
<p><code>PerformanceTiming</code>对象包含了各种与浏览器性能有关的时间数据，提供浏览器处理网页各个阶段的耗时，它包含的页面性能属性如下表：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>navigationStart</td>
<td>准备加载新页面的起始时间</td>
</tr>
<tr>
<td>redirectStart</td>
<td>如果发生了HTTP重定向，并且从导航开始，中间的每次重定向，都和当前文档同域的话，就返回开始重定向的timing.fetchStart的值。其他情况，则返回0</td>
</tr>
<tr>
<td>redirectEnd</td>
<td>如果发生了HTTP重定向，并且从导航开始，中间的每次重定向，都和当前文档同域的话，就返回最后一次重定向，接收到最后一个字节数据后的那个时间.其他情况则返回0</td>
</tr>
<tr>
<td>fetchStart</td>
<td>如果一个新的资源获取被发起，则 fetchStart必须返回用户代理开始检查其相关缓存的那个时间，其他情况则返回开始获取该资源的时间</td>
</tr>
<tr>
<td>domainLookupStart</td>
<td>返回用户代理对当前文档所属域进行DNS查询开始的时间。如果此请求没有DNS查询过程，如长连接，资源cache,甚至是本地资源等。 那么就返回 fetchStart的值</td>
</tr>
<tr>
<td>domainLookupEnd</td>
<td>返回用户代理对结束对当前文档所属域进行DNS查询的时间。如果此请求没有DNS查询过程，如长连接，资源cache，甚至是本地资源等。那么就返回 fetchStart的值</td>
</tr>
<tr>
<td>connectStart</td>
<td>返回用户代理向服务器服务器请求文档，开始建立连接的那个时间，如果此连接是一个长连接，又或者直接从缓存中获取资源（即没有与服务器建立连接）。则返回domainLookupEnd的值</td>
</tr>
<tr>
<td>(secureConnectionStart)</td>
<td>可选特性。用户代理如果没有对应的东东，就要把这个设置为undefined。如果有这个东东，并且是HTTPS协议，那么就要返回开始SSL握手的那个时间。 如果不是HTTPS， 那么就返回0</td>
</tr>
<tr>
<td>connectEnd</td>
<td>返回用户代理向服务器服务器请求文档，建立连接成功后的那个时间，如果此连接是一个长连接，又或者直接从缓存中获取资源（即没有与服务器建立连接）。则返回domainLookupEnd的值</td>
</tr>
<tr>
<td>requestStart</td>
<td>返回从服务器、缓存、本地资源等，开始请求文档的时间</td>
</tr>
<tr>
<td>responseStart</td>
<td>返回用户代理从服务器、缓存、本地资源中，接收到第一个字节数据的时间</td>
</tr>
<tr>
<td>responseEnd</td>
<td>返回用户代理接收到最后一个字符的时间，和当前连接被关闭的时间中，更早的那个。同样，文档可能来自服务器、缓存、或本地资源</td>
</tr>
<tr>
<td>domLoading</td>
<td>返回用户代理把其文档的 “current document readiness” 设置为 “loading”的时候</td>
</tr>
<tr>
<td>domInteractive</td>
<td>返回用户代理把其文档的 “current document readiness” 设置为 “interactive”的时候.</td>
</tr>
<tr>
<td>domContentLoadedEventStart</td>
<td>返回文档发生 DOMContentLoaded事件的时间</td>
</tr>
<tr>
<td>domContentLoadedEventEnd</td>
<td>文档的DOMContentLoaded 事件的结束时间</td>
</tr>
<tr>
<td>domComplete</td>
<td>返回用户代理把其文档的 “current document readiness” 设置为 “complete”的时候</td>
</tr>
<tr>
<td>loadEventStart</td>
<td>文档触发load事件的时间。如果load事件没有触发，那么该接口就返回0</td>
</tr>
<tr>
<td>loadEventEnd</td>
<td>文档触发load事件结束后的时间。如果load事件没有触发，那么该接口就返回0</td>
</tr>
</tbody>
</table>
<p>一般来说，我们需要获取到的页面性能参数包括：<strong>DNS查询耗时、TCP链接耗时、request请求耗时、解析dom树耗时、白屏时间、domready时间、onload时间</strong>等，而这些参数是通过上面的<code>performance.timing</code>各个属性的差值组成的，计算方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DNS查询耗时 ：domainLookupEnd - domainLookupStart</span><br><span class="line">TCP链接耗时 ：connectEnd - connectStart</span><br><span class="line">request请求耗时 ：responseEnd - responseStart</span><br><span class="line">解析dom树耗时 ： domComplete - domInteractive</span><br><span class="line">白屏时间 ：responseStart - navigationStart</span><br><span class="line">domready时间 ：domContentLoadedEventEnd - navigationStart</span><br><span class="line">onload时间 ：loadEventEnd - navigationStart</span><br></pre></td></tr></table></figure>
<p><code>Navigation Timing</code>的目的是用于分析页面整体性能指标。如果要获取个别资源（例如JS、图片）的性能指标，就需要使用<code>Resource Timing API</code>。</p>
<h2 id="Resource_Timing">Resource Timing</h2><p>浏览器获取网页时，会对网页中每一个静态资源（脚本文件、样式表、图片文件等等）发出一个HTTP请求。<code>Resource Timing</code>可以获取到单个静态资源从开始发出请求到获取响应之间各个阶段的Timing。用法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resourcesObj = performance.getEntries();</span><br></pre></td></tr></table></figure>
<p><code>Resource Timing</code>返回的是一个对象数组，数组的每一个项都是一个对象，这个对象中包含了当前静态资源的加载Timing，如下图：</p>
<p><img src="/images/performance/performancetiming02.png" alt="PerformanceTiming"></p>
<p>我们可以根据数组的长度获取到页面中静态资源的数量，然后通过数组的每一项分析单个静态资源的请求状态。</p>
<p><code>performance</code>中还有一些性能API尚未成为W3C标准（如第一张图中的工作进度），有的处于编辑草案阶段，有的处于工作草案阶段，当这些API逐渐成为推荐标准以后，一定会对我们进行前端性能监控带来很大的便利，我们也可以通过这些API很方便地直接从页面中获取到我们希望得到的性能信息。</p>
<h2 id="相关资源">相关资源</h2><p><a href="http://javascript.ruanyifeng.com/bom/performance.html" target="_blank" rel="external">performance API</a></p>
<p><a href="https://github.com/fredshare/blog/issues/5" target="_blank" rel="external">window.performance 详解</a></p>
<p><a href="http://www.cnblogs.com/mrsunny/archive/2012/09/04/2670727.html" target="_blank" rel="external">使用简洁的 Navigation Timing API 测试网页加载速度（不完全译文）</a></p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/performance/" class="post__tag__link">performance</a></li><li class="post__tag__item"><a href="/tags/前端性能/" class="post__tag__link">前端性能</a></li><li class="post__tag__item"><a href="/tags/原创/" class="post__tag__link">原创</a></li></ul><a class="post__foot-link u-fr"></a></footer></article><article class="post"><header class="post__head"><time datetime="2015-09-08T08:28:17.000Z" class="post__time">September 8, 2015</time><h1 class="post__title"><a href="/2015/09/08/har-detail/">HAR文件详细解析</a></h1><hr/></header><div class="post__main echo"><p>HAR（HTTP档案规范），是一个用来储存HTTP请求/响应信息的通用文件格式，基于JSON。这种格式的数据可以使HTTP监测工具以一种通用的格式导出所收集的数据，这些数据可以被其他支持HAR的HTTP分析工具（包括Firebug、httpwatch、Fiddler等）所使用，来分析网站的性能瓶颈。</p>
<p>目前HAR规范最新版本为HAR 1.2。HAR文件必须是UTF-8编码，有无BOM无所谓。如下是一个HAR文件的详细介绍。</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"log"</span>: &#123;</span><br><span class="line">        <span class="string">"version"</span>: <span class="string">"1.2"</span>,</span><br><span class="line">        <span class="string">"creator"</span>: &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"shun.zheng"</span>,</span><br><span class="line">            <span class="string">"version"</span>: <span class="string">"1.1.8"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"pages"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"startedDateTime"</span>: <span class="string">"2015-09-06T10:02:41.663Z"</span>, <span class="comment">// 页面开始加载的时间（格式：ISO 8601）</span></span><br><span class="line">                <span class="string">"id"</span>: <span class="string">"http://www.ihorve.com/"</span>, <span class="comment">// 页面唯一标示符，即页面url</span></span><br><span class="line">                <span class="string">"title"</span>: <span class="string">"Horve后花园"</span>, <span class="comment">// 页面标题</span></span><br><span class="line">                <span class="string">"pageTimings"</span>: &#123; <span class="comment">// 关于页面加载时间的详细信息</span></span><br><span class="line">                    <span class="string">"onContentLoad"</span>: <span class="number">1720</span>, <span class="comment">// 可选，页面开始加载到页面内容加载完毕之间的毫秒数</span></span><br><span class="line">                    <span class="string">"onLoad"</span>: <span class="number">2500</span>, <span class="comment">// 可选，页面开始加载到页面onload之间的毫秒数</span></span><br><span class="line">                    <span class="string">"comment"</span>: <span class="string">""</span> <span class="comment">// 可选，由用户或应用程序提供的注释</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"entries"</span>: [ <span class="comment">// 包含全部请求的数组，数组的每一项是一条请求的数据构成的对象，根据startedDateTime排序</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"startedDateTime"</span>: <span class="string">"2015-09-06T10:02:41.645Z"</span>, <span class="comment">// 请求发出的时间(ISO 8601)</span></span><br><span class="line">                <span class="string">"time"</span>: <span class="number">1221</span>, <span class="comment">// 该条请求花费的总的毫秒数</span></span><br><span class="line">                <span class="string">"request"</span>: &#123; <span class="comment">// 请求的详细情况</span></span><br><span class="line">                    <span class="string">"method"</span>: <span class="string">"GET"</span>, <span class="comment">// 请求方式</span></span><br><span class="line">                    <span class="string">"url"</span>: <span class="string">"http://www.ihorve.com/"</span>, <span class="comment">// 请求的url</span></span><br><span class="line">                    <span class="string">"httpVersion"</span>: <span class="string">"HTTP/1.1"</span>, <span class="comment">// http协议版本号</span></span><br><span class="line">                    <span class="string">"cookies"</span>: [], <span class="comment">// cookie对象列表</span></span><br><span class="line">                    <span class="string">"headers"</span>: [ <span class="comment">// header信息</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">"name"</span>: <span class="string">"User-Agent"</span>,</span><br><span class="line">                            <span class="string">"value"</span>: <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X) AppleWebKit/534.34 (KHTML, like Gecko) PhantomJS/1.9.8 Safari/534.34"</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">"name"</span>: <span class="string">"Accept"</span>,</span><br><span class="line">                            <span class="string">"value"</span>: <span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    ],</span><br><span class="line">                    <span class="string">"queryString"</span>: [], <span class="comment">// 查询参数对象的列表</span></span><br><span class="line">                    <span class="string">"headersSize"</span>: -<span class="number">1</span>, <span class="comment">// 从HTTP请求消息的开始，直到（且包括）的主体之前的双CRLF的总字节数，不可用设置为-1</span></span><br><span class="line">                    <span class="string">"bodySize"</span>: -<span class="number">1</span> <span class="comment">// 消息体的粽子节数，不可用设置为-1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"response"</span>: &#123; <span class="comment">// 响应的详细情况</span></span><br><span class="line">                    <span class="string">"status"</span>: <span class="number">200</span>, <span class="comment">// 状态码</span></span><br><span class="line">                    <span class="string">"statusText"</span>: <span class="string">"OK"</span>,</span><br><span class="line">                    <span class="string">"httpVersion"</span>: <span class="string">"HTTP/1.1"</span>,</span><br><span class="line">                    <span class="string">"cookies"</span>: [], <span class="comment">// cookie对象列表</span></span><br><span class="line">                    <span class="string">"headers"</span>: [ <span class="comment">// 响应头信息列表</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">"name"</span>: <span class="string">"Server"</span>,</span><br><span class="line">                            <span class="string">"value"</span>: <span class="string">"nginx"</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">"name"</span>: <span class="string">"Date"</span>,</span><br><span class="line">                            <span class="string">"value"</span>: <span class="string">"Sun, 06 Sep 2015 09:59:22 GMT"</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">"name"</span>: <span class="string">"Content-Type"</span>,</span><br><span class="line">                            <span class="string">"value"</span>: <span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">"name"</span>: <span class="string">"Transfer-Encoding"</span>,</span><br><span class="line">                            <span class="string">"value"</span>: <span class="string">"chunked"</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">"name"</span>: <span class="string">"Connection"</span>,</span><br><span class="line">                            <span class="string">"value"</span>: <span class="string">"keep-alive"</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">"name"</span>: <span class="string">"Keep-Alive"</span>,</span><br><span class="line">                            <span class="string">"value"</span>: <span class="string">"timeout=60"</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">"name"</span>: <span class="string">"X-Pingback"</span>,</span><br><span class="line">                            <span class="string">"value"</span>: <span class="string">"http://www.ihorve.com/xmlrpc.php"</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">"name"</span>: <span class="string">"Content-Encoding"</span>,</span><br><span class="line">                            <span class="string">"value"</span>: <span class="string">"gzip"</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    ],</span><br><span class="line">                    <span class="string">"redirectURL"</span>: <span class="string">""</span>, <span class="comment">// 从响应头位置重定向目标URL</span></span><br><span class="line">                    <span class="string">"headersSize"</span>: -<span class="number">1</span>, <span class="comment">// 从HTTP响应消息的开始，直到（且包括）的主体之前的双CRLF的总字节数，不可用设置为-1</span></span><br><span class="line">                    <span class="string">"bodySize"</span>: <span class="number">65047</span>, <span class="comment">// 响应体的字节数</span></span><br><span class="line">                    <span class="string">"content"</span>: &#123; <span class="comment">// 响应体的详细信息</span></span><br><span class="line">                        <span class="string">"size"</span>: <span class="number">65047</span>, <span class="comment">// 响应体的字节数</span></span><br><span class="line">                        <span class="string">"mimeType"</span>: <span class="string">"text/html; charset=UTF-8"</span> <span class="comment">// 响应体的mimeType</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"cache"</span>: &#123; <span class="comment">// 请求从浏览器缓存的信息</span></span><br><span class="line">                    <span class="string">"beforeRequest"</span>: &#123;&#125;, <span class="comment">// 可选，请求前缓存条目的状态</span></span><br><span class="line">                    <span class="string">"afterRequest"</span>: &#123;&#125;, <span class="comment">// 可选，请求后缓存条目的状态</span></span><br><span class="line">                    <span class="string">"comment"</span>: <span class="string">""</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"timings"</span>: &#123; <span class="comment">// 发送请求到收到响应各阶段的时间，单位均为毫秒</span></span><br><span class="line">                    <span class="string">"blocked"</span>: <span class="number">0</span>, <span class="comment">// 可选，等待网络连接的时间</span></span><br><span class="line">                    <span class="string">"dns"</span>: -<span class="number">1</span>, <span class="comment">// 可选，dns解析时间，不可用设置为-1</span></span><br><span class="line">                    <span class="string">"connect"</span>: -<span class="number">1</span>, <span class="comment">// 可选，创建TCP连接的时间，不可用设置为-1</span></span><br><span class="line">                    <span class="string">"send"</span>: <span class="number">0</span>, <span class="comment">// 发送HTTP请求到服务器的时间</span></span><br><span class="line">                    <span class="string">"wait"</span>: <span class="number">1126</span>, <span class="comment">// 等待响应的时间</span></span><br><span class="line">                    <span class="string">"receive"</span>: <span class="number">95</span>, <span class="comment">// 从服务器接收或从缓存读取的时间</span></span><br><span class="line">                    <span class="string">"ssl"</span>: -<span class="number">1</span> <span class="comment">// 可选，SSL/TLS协商需要的时间，不可用设置为-1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"pageref"</span>: <span class="string">"http://www.ihorve.com/"</span> <span class="comment">// 可选，唯一，参照的父页面，如果应用不支持页面分组，可忽略此项配置</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/har/" class="post__tag__link">har</a></li><li class="post__tag__item"><a href="/tags/phantomjs/" class="post__tag__link">phantomjs</a></li><li class="post__tag__item"><a href="/tags/原创/" class="post__tag__link">原创</a></li></ul><a class="post__foot-link u-fr"></a></footer></article><article class="post"><header class="post__head"><time datetime="2015-09-01T03:00:00.000Z" class="post__time">September 1, 2015</time><h1 class="post__title"><a href="/2015/09/01/js-inject/">chrome浏览器拓展——js脚本拦截及注入</a></h1><hr/></header><div class="post__main echo"><h3 id="概要">概要</h3><p>该浏览器拓展插件是拥有为页面拦截和注入js功能的chrome浏览器扩展，可以拦截页面脚本、检索页面脚本文件、下载页面脚本文件、为页面注入js文件，以及为页面注入requirejs和requirejs入口文件。<br><a id="more"></a></p>
<h3 id="安装方式">安装方式</h3><h4 id="拓展为开发版本，尚未打包发布，安装时需要将项目文件更新到本地，具体如下：">拓展为开发版本，尚未打包发布，安装时需要将项目文件更新到本地，具体如下：</h4><ul>
<li><p>1，更新项目到本地目录，如：/users/js_inject</p>
</li>
<li><p>2，在chrome浏览器中打开 chrome://extensions/ </p>
</li>
<li><p>3，点击“加载正在开发的拓展程序”按钮</p>
</li>
<li><p>4，选择/users/js_inject目录，确定</p>
</li>
<li><p>5，浏览器地址栏右边的艺龙logo小图标，即为拓展插件的入口</p>
</li>
</ul>
<h3 id="自定义">自定义</h3><h4 id="在本版插件中，预设了一些默认设定，可以根据实际需求进行修改。功能点、配置文件位置、如何修改详情如下：">在本版插件中，预设了一些默认设定，可以根据实际需求进行修改。功能点、配置文件位置、如何修改详情如下：</h4><h4 id="1，配置需要开启js拦截功能的站点域名。“background-js”_文件中的如下位置：">1，配置需要开启js拦截功能的站点域名。“background.js” 文件中的如下位置：</h4><pre><code><span class="symbol">urls:</span> [
    <span class="string">"*://*.jquery.top/*"</span>, <span class="regexp">//</span>域名过滤器，*<span class="symbol">://*/*</span> 表示所有协议、所有域名、域名下的所有资源均匹配 
    <span class="string">"*://*.baidu.com/*"</span>
],
</code></pre><h4 id="2，配置拓展启动时需要向页面注入的资源。“manifest-json”_文件中的如下位置：">2，配置拓展启动时需要向页面注入的资源。“manifest.json” 文件中的如下位置：</h4><pre><code><span class="string">"content_scripts"</span>: [
    {
        <span class="string">"matches"</span>: [<span class="string">"http://*/*"</span>], <span class="comment">//域名过滤器</span>
        <span class="string">"js"</span>: [<span class="string">"jquery-1.9.1.js"</span>], <span class="comment">//需要向页面中注入的脚本资源</span>
        <span class="string">"run_at"</span>: <span class="string">"document_end"</span>   <span class="comment">//注入时机，该选项表明是文档节点加载完成后注入</span>
    }
],
</code></pre><h4 id="3，配置拓展包内资源引用权限。“manifest-json”_文件中的如下位置：">3，配置拓展包内资源引用权限。“manifest.json” 文件中的如下位置：</h4><pre><code><span class="string">"web_accessible_resources"</span>: [
    <span class="string">"require.js"</span>,
    <span class="string">"returnjs.js"</span>,
    <span class="string">"images/*"</span>
]
</code></pre><h3 id="功能点">功能点</h3><h4 id="1，脚本拦截功能">1，脚本拦截功能</h4><p>打开拦截匹配的域名链接后，拓展会自动拦截页面中引入的所有的外部脚本资源。</p>
<h4 id="2，js脚本检索功能">2，js脚本检索功能</h4><p>打开拓展界面后，即会加载出页面中所有引用的外部js脚本列表，可以通过“检索URL”输入框对脚本关键字进行检索。</p>
<h4 id="3，下载选中脚本">3，下载选中脚本</h4><p>点击“下载选中脚本”按钮可以下载已经选中的检索出的脚本文件。</p>
<h4 id="4，向页面中注入指定脚本（远程脚本）">4，向页面中注入指定脚本（远程脚本）</h4><p>4.1  普通注入方式</p>
<p>普通注入方式将直接向页面中注入在“脚本URL”文本框中输入的远程脚本并立即执行。</p>
<p>4.2 requirejs入口脚本方式注入</p>
<p>该方式将首先向页面注入require.js，随后将把“脚本URL”文本框中输入的远程脚本作为requirejs的入口脚本执行。</p>
<p>注：脚本URL文本框中默认的远程url即通过requirejs入口脚本方式注入的demo，注入的main.js文件将依赖jQuery.js和另一个自定义模块count.js，注入后会更改页面背景色为红色，并在控制台输出“111+222”的计算结果。</p>
<h3 id="外部API资源文档">外部API资源文档</h3><p>360极速浏览器开放平台（chrome官方API的中文版本，但不是最新）： <a href="http://open.chrome.360.cn/extension_dev/overview.html" target="_blank" rel="external">http://open.chrome.360.cn/extension_dev/overview.html</a></p>
<p>chrome插件中文开发文档（非官方，与官方文档一致，不用翻墙）： <a href="http://chrome.liuyixi.com/overview.html" target="_blank" rel="external">http://chrome.liuyixi.com/overview.html</a></p>
<p>Chrome扩展及应用开发（电子书）： <a href="http://www.ituring.com.cn/book/1472" target="_blank" rel="external">http://www.ituring.com.cn/book/1472</a></p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/chrome/" class="post__tag__link">chrome</a></li><li class="post__tag__item"><a href="/tags/chrome-extension/" class="post__tag__link">chrome-extension</a></li><li class="post__tag__item"><a href="/tags/原创/" class="post__tag__link">原创</a></li></ul><a class="post__foot-link u-fr"></a></footer></article></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2016 Horve<bdi> Theme by <a href="https://github.com/andforce/hexo-theme-andforce" >andforce</a></bdi></div><menu class="page-menu u-fr"><li class="page-menu__item"><span title="Previous" class="page-menu__link icon-arrow-left page-menu__link--disabled"></span></li><li class="page-menu__item"><span title="Next" class="page-menu__link icon-arrow-right page-menu__link--disabled"></span></li></menu></footer></body></html>
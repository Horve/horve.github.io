<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="Horve的前端笔记" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>前端性能 - Horve的前端笔记</title><link rel="stylesheet" href="/css/main.css" type="text/css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"><a href="/">Horve的前端笔记</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/archives" class="head-nav__link">文章</a></li><li class="head-nav__item"><a href="http://weibo.com/andforce" class="head-nav__link">微博</a></li><li class="head-nav__item"><a href="https://github.com/andforce" class="head-nav__link">GitHub</a></li><li class="head-nav__item"><a href="https://bintray.com/andforce" class="head-nav__link">Bintray</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2015-10-26T06:59:25.000Z" class="post__time">October 26, 2015</time><h1 class="post__title"><a href="/2015/10/26/timeline/">使用Chrome DevTools的Timeline分析页面性能</a></h1><hr/></header><div class="post__main echo"><p>随着webpage可以承载的表现形式更加多样化，通过webpage来实现更多交互功能，构建web应用程序已经成为很多产品的首要选择。这种方式拥有非常明显的优势：跨平台、开发便捷、便于部署和维护等等，但随着功能的不断积累，web应用程序也会变得越来越复杂。但是，我们仍然想要在webpage支持丰富的呈现形式的同时，让页面效果能够达到&gt;=60fps(帧)/s的刷新频率以避免出现卡顿，就需要我们使用一些比较直观的方式来分析衡量页面的性能问题，为性能优化方案提供依据。</p>
<blockquote>
<p>为什么是60fps?<br>我们的目标是保证页面要有高于每秒60fps(帧)的刷新频率，这和目前大多数显示器的刷新率相吻合(60Hz)。如果网页动画能够做到每秒60帧，就会跟显示器同步刷新，达到最佳的视觉效果。这意味着，一秒之内进行60次重新渲染，每次重新渲染的时间不能超过16.66毫秒。</p>
</blockquote>
<a id="more"></a>
<p>需求大体明确，就是要找到页面执行过程中的性能瓶颈。而Chrome DevTools的Timeline则正是用来记录和分析应用在运行时所有的活动情况，它是用来排查应用性能瓶颈的最佳工具。</p>
<p>下图是Timeline面板的预览效果：</p>
<p><img src="/images/timeline/timeline-preview.png" alt="Timeline预览效果图"></p>
<blockquote>
<p>Tips:为了避免浏览器插件对分析过程产生影响，建议在隐身模式下进行分析。</p>
</blockquote>
<h2 id="Timeline工具栏介绍">Timeline工具栏介绍</h2><p>Timeline工具会详细检测出在Web应用加载的过程中时间花费情况的概览，包括下载资源、处理DOM事件、页面布局渲染、向屏幕绘制元素等。你可以通过分析Timeline得到的事件、框架和实时的内存用量，找出应用的性能问题。</p>
<p><img src="/images/timeline/timeline-1.png" alt="Timeline的两种模式"></p>
<p>在分析页面前，需要首先开启录制功能，记录页面的操作和渲染记录。如上图，左上角的灰色圆点就是录制按钮，点击后会变成红色，然后在页面上进行相关操作后再次按下变成灰色完成录制，这样就完成了一次对操作及加载渲染的记录过程，随后Timeline就会开始分析操作过程中的各项性能参数。</p>
<p>Timeline同时提供了两种查看模式：“事件模式(Event Mode)”和“帧模式(Frame Mode)”。如上图箭头所示。</p>
<blockquote>
<p>事件模式：显示重新渲染的各种事件花费的时间。<br>帧模式：显示每一帧的时间花费情况。</p>
</blockquote>
<h2 id="事件模式_(Event_Mode)">事件模式 (Event Mode)</h2><p>如果我们的一个页面执行效率不高，我们必须要搞清楚导致页面性能低下的原因，到底是javascript执行出了问题，还是页面渲染出了问题。要了解这里面的执行细节，我们可以使用“事件模式”来进行分析。首先我们需要录制一些需要被分析的操作，录制结束后进入事件模式预览Timeline。下图是得到的事件模式的视图：</p>
<p><img src="/images/timeline/timeline-2.png" alt="事件模式"></p>
<p>在上图中，不同的颜色表示不同的事件。一种颜色的区块越长，说明在处理该事件的耗时就越长。单击某一区块，可以在下面的Summary概要中看到详细的事件处理过程及耗时分布。</p>
<p><img src="/images/timeline/timeline-3.png" alt="事件类别"></p>
<blockquote>
<p>蓝色(Loading)：网络通信和HTML解析<br>黄色(Scripting)：JavaScript执行<br>紫色(Rendering)：样式计算和布局，即重排<br>绿色(Painting)：重绘<br>灰色(other)：其它事件花费的时间<br>白色(Idle)：空闲时间</p>
</blockquote>
<p>在显示的记录中，浏览器也会为在检测过程中发现的一些可能导致性能问题的过程进行标注，在<code>Mode View</code>视图区域，可能会出现一些红色的区块段，这些红色的区块段表明，在对应的时间上执行的事件可能存在性能问题，而在对应的<code>Main Thread</code>视图区域，事件区块的右上角会出现红色的小三角，点击当前区块，在下面的<code>Summary</code>概要区域内会给出详细的警告内容以及脚本可能出现问题的行数，如下图，浏览器提示“强制同步布局可能会导致性能瓶颈”：</p>
<p><img src="/images/timeline/timeline-4.png" alt="性能问题标注"></p>
<p>此外，在关闭Event Mode后，还可以看到Record Detail视图，详细列出一次记录中各类事件的详细内容。</p>
<p><img src="/images/timeline/timeline-5.png" alt="Record Detail视图"></p>
<p><code>Record Detail</code>视图区域的左侧是事件标题，右侧是对应的时间线。点击每一条时间标题可以看到更多信息，如事件发生在脚本的哪一行等。如果你只对某一个时间段内的某些操作感兴趣，可以通过移动时间轴的始末位置来选择要浏览的区域：</p>
<p><img src="/images/timeline/timeline-6.png" alt="选取一部分记录"></p>
<p>在<code>Summary</code>面板及<code>Record Detail</code>视图中，事件的<code>Type</code>列表如下：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Info</th>
</tr>
</thead>
<tbody>
<tr>
<td>send request</td>
<td>发送请求</td>
</tr>
<tr>
<td>evaluate script</td>
<td>评估脚本</td>
</tr>
<tr>
<td>parse html</td>
<td>html解析</td>
</tr>
<tr>
<td>recalculate style</td>
<td>重新计算显示样式</td>
</tr>
<tr>
<td>layout</td>
<td>计算布局</td>
</tr>
<tr>
<td>paint setup</td>
<td>绘制设置【准备绘制】</td>
</tr>
<tr>
<td>paint</td>
<td>绘制</td>
</tr>
<tr>
<td>composite layers</td>
<td>组合层</td>
</tr>
<tr>
<td>timer fired</td>
<td>触发定时器</td>
</tr>
<tr>
<td>function call</td>
<td>函数调用</td>
</tr>
<tr>
<td>receive data</td>
<td>接收数据</td>
</tr>
<tr>
<td>receive response</td>
<td>接受响应</td>
</tr>
<tr>
<td>finish loading</td>
<td>结束加载</td>
</tr>
<tr>
<td>GC event</td>
<td>浏览器垃圾回收</td>
</tr>
<tr>
<td>pevaluate script</td>
<td>评估脚本</td>
</tr>
<tr>
<td>rasterize</td>
<td>栅格化</td>
</tr>
</tbody>
</table>
<h2 id="帧模式_(Frame_Mode)">帧模式 (Frame Mode)</h2><p>帧模式从页面渲染性能的角度提供了数据支撑，一个柱状“frame”表示渲染过程中的一帧，也就是浏览器为了渲染单个内容块而必须要做的工作，包括：执行js，处理事件，修改DOM，更改样式和布局，绘制页面等。</p>
<p>如前文所述，我们的目标是保证页面要有高于每秒60fps(帧)的刷新频率，这样就能保证页面有高流畅度的渲染。</p>
<p><img src="/images/timeline/timeline-7.png" alt="帧模式视图"></p>
<p>中在Frame视图中有两条贯穿该视图的横线，分别标识出60FPS和30FPS的基准，按照前面提到的16.66ms的计算方式，我们可以理解为分别标识了16.6ms和33.3ms两个时间点。下面的一条是60FPS，低于这条线，可以达到每秒60帧；上面的一条是30FPS，低于这条线，可以达到每秒30次渲染。如果色柱都超过30FPS，这个网页就有性能问题了。</p>
<p>图中帧柱的高度表示了该帧的总耗时，帧柱中的颜色分别对应该帧中包含的不停类型的事件。每一帧柱的高度越低越好，上图是艺龙PC首页(www.elong.com)的帧渲染图，从图中可以看出，在进行某些帧的渲染时，帧的渲染频率低于30FPS/s，第二帧和第三帧就大幅低于30fps(帧柱高度高于30fps标准线)，在实际浏览器渲染中就有可能出现卡顿。对相关的帧进行分析时，可以点击其中某一帧查看渲染详情，也可以选择某个区域的几个帧查看渲染详情。而要找出可能影响性能的原因，点击当前问题帧，在<code>Summary</code>面板及<code>Record Detail</code>视图中的详细信息中进行逐条分析。</p>
<blockquote>
<p>你可能注意到了在帧柱上存在灰色区域和空白区域,它们分别代表：<br>灰色区块：那些没有被DevTools感知到的活动<br>空白区块：显示刷新周期（display refresh cycles）中的空闲时间段</p>
</blockquote>
<p>点击某一个帧柱还可以得到该帧的详细记录数据：</p>
<p><img src="/images/timeline/timeline-8.png" alt="帧详情"></p>
<blockquote>
<p>Warning: 警告信息<br>ScreenShot: 当前选中帧的渲染截屏<br>Duration: 该记录及其子记录的总耗时<br>FPS: 当前帧的渲染频率<br>CPU Time: CPU耗时<br>Aggregated Time: 合计耗时分布</p>
</blockquote>
<h2 id="总结">总结</h2><p>发现问题是解决问题的第一步，chrome浏览器的TimeLine工具可以很好地辅助我们分析页面的性能瓶颈，提供详细全面的分析数据，为我们进行性能优化提供数据依据。当然，TimeLine中有用的功能还有很多，比如<code>Memery Mode</code>, <code>Screen Shot</code>等，使用技巧多种多样，在这里主要介绍了如何去记录一段渲染过程，如何去使用<code>Event Mode</code>和<code>Frame Mode</code>去查看并分析得到性能指标，后续如果有新的体会和发现，还会再做记录~</p>
<h2 id="TimeLine中的事件汇总">TimeLine中的事件汇总</h2><h3 id="Loading事件">Loading事件</h3><table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parse HTML</td>
<td>浏览器执行HTML解析</td>
</tr>
<tr>
<td>Finish Loading</td>
<td>网络请求完毕事件</td>
</tr>
<tr>
<td>Receive Data</td>
<td>请求的响应数据到达事件，如果响应数据很大（拆包），可能会多次触发该事件</td>
</tr>
<tr>
<td>Receive Response</td>
<td>响应头报文到达时触发</td>
</tr>
<tr>
<td>Send Request</td>
<td>发送网络请求时触发</td>
</tr>
</tbody>
</table>
<h3 id="Scripting事件">Scripting事件</h3><table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Animation Frame Fired</td>
<td>一个定义好的动画帧发生并开始回调处理时触发</td>
</tr>
<tr>
<td>Cancel Animation Frame</td>
<td>取消一个动画帧时触发</td>
</tr>
<tr>
<td>GC Event</td>
<td>垃圾回收时触发</td>
</tr>
<tr>
<td>DOMContentLoaded</td>
<td>当页面中的DOM内容加载并解析完毕时触发</td>
</tr>
<tr>
<td>Evaluate Script</td>
<td>A script was evaluated.</td>
</tr>
<tr>
<td>Event</td>
<td>js事件</td>
</tr>
<tr>
<td>Function Call</td>
<td>只有当浏览器进入到js引擎中时触发</td>
</tr>
<tr>
<td>Install Timer</td>
<td>创建计时器（调用setTimeout()和setInterval()）时触发</td>
</tr>
<tr>
<td>Request Animation Frame</td>
<td>A requestAnimationFrame() call scheduled a new frame</td>
</tr>
<tr>
<td>Remove Timer</td>
<td>当清除一个计时器时触发</td>
</tr>
<tr>
<td>Time</td>
<td>调用console.time()触发</td>
</tr>
<tr>
<td>Time End</td>
<td>调用console.timeEnd()触发</td>
</tr>
<tr>
<td>Timer Fired</td>
<td>定时器激活回调后触发</td>
</tr>
<tr>
<td>XHR Ready State Change</td>
<td>当一个异步请求为就绪状态后触发</td>
</tr>
<tr>
<td>XHR Load</td>
<td>当一个异步请求完成加载后触发</td>
</tr>
</tbody>
</table>
<h3 id="Rendering事件">Rendering事件</h3><table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Invalidate layout</td>
<td>当DOM更改导致页面布局失效时触发</td>
</tr>
<tr>
<td>Layout</td>
<td>页面布局计算执行时触发</td>
</tr>
<tr>
<td>Recalculate style</td>
<td>Chrome重新计算元素样式时触发</td>
</tr>
<tr>
<td>Scroll</td>
<td>内嵌的视窗滚动时触发</td>
</tr>
</tbody>
</table>
<h3 id="Painting事件">Painting事件</h3><table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Composite Layers</td>
<td>Chrome的渲染引擎完成图片层合并时触发</td>
</tr>
<tr>
<td>Image Decode</td>
<td>一个图片资源完成解码后触发</td>
</tr>
<tr>
<td>Image Resize</td>
<td>一个图片被修改尺寸后触发</td>
</tr>
<tr>
<td>Paint</td>
<td>合并后的层被绘制到对应显示区域后触发</td>
</tr>
</tbody>
</table>
<h2 id="参考文档">参考文档</h2><p><a href="https://developers.google.com/chrome-developer-tools/docs/timeline" target="_blank" rel="external">https://developers.google.com/chrome-developer-tools/docs/timeline</a></p>
<p><a href="http://www.w3cfuns.com/article-1248-1.html" target="_blank" rel="external">http://www.w3cfuns.com/article-1248-1.html</a></p>
<p><a href="http://www.oschina.net/translate/performance-optimisation-with-timeline-profiles" target="_blank" rel="external">http://www.oschina.net/translate/performance-optimisation-with-timeline-profiles</a></p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/timeline/" class="post__tag__link">timeline</a></li><li class="post__tag__item"><a href="/tags/前端性能/" class="post__tag__link">前端性能</a></li></ul><a class="post__foot-link u-fr"></a></footer></article><article class="post"><header class="post__head"><time datetime="2015-09-14T12:15:31.000Z" class="post__time">September 14, 2015</time><h1 class="post__title"><a href="/2015/09/14/performanceAPI/">使用性能API快速分析web前端性能</a></h1><hr/></header><div class="post__main echo"><p>页面的性能问题一直是产品开发过程中的重要一环，很多公司也一直在使用各种方式监控产品的页面性能。从控制台工具、Fiddler抓包工具，到使用<code>DOMContentLoaded</code>和<code>document.onreadystatechange</code>这种侵入式javascript代码方式来检测DOM事件发生和结束的时间，再到使用第三方工具如<code>WebPagetest</code>、<code>Pingdom</code>等通过在不同的浏览器环境和地域进行测试来寻求优化建议等等，这些方式不仅麻烦，而且测量的指标比较单一。如果有一些可以帮我们直接获取页面性能信息的API出现，并且成为标准被被浏览器厂商支持，那性能监控会不会又是另一幅蓝图？</p>
<a id="more"></a>
<p>好在W3C Web性能工作小组与各浏览器厂商都已认识到性能对于web开发的重要性，为了解决当前性能测试的困难，W3C推出了一套性能API标准，各种浏览器对这套标准的支持如今也逐渐成熟起来。这套API的目的是简化开发者对网站性能进行精确分析与控制的过程，方便开发者采取手段提高web性能。</p>
<p>整套标准包含了10余种API，各自针对性能检测的某个方面。在下图中可以看到它们当前在规范流程中的进展：</p>
<p><img src="/images/performance/1.png" alt="API进展"></p>
<h2 id="下面是API及描述其功能的列表：">下面是API及描述其功能的列表：</h2><table>
<thead>
<tr>
<th style="text-align:left">API</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Navigation Timing</td>
<td style="text-align:left">导航计时</td>
<td style="text-align:left">能够帮助网站开发者检测真实用户数据（RUM），例如带宽、延迟或主页的整体页面加载时间。</td>
</tr>
<tr>
<td style="text-align:left">Resource Timing</td>
<td style="text-align:left">资源计时</td>
<td style="text-align:left">对单个资源的计时，可以对细粒度的用户体验进行检测。</td>
</tr>
<tr>
<td style="text-align:left">High Resolution Timing</td>
<td style="text-align:left">高精度计时</td>
<td style="text-align:left">该API规范所定义的JavaScript接口能够提供精确到微秒级的当前时间，并且不会受到系统时钟偏差或调整的影响。</td>
</tr>
<tr>
<td style="text-align:left">Page Visibility</td>
<td style="text-align:left">页面可见性</td>
<td style="text-align:left">通过这一规范，网站开发者能够以编程方式确定页面的当前可见状态，从而使网站能够更有效地利用电源与CPU。当页面获得或失去焦点时，文档对象的visibilitychange事件便会被触发。</td>
</tr>
<tr>
<td style="text-align:left">Performance Timeline</td>
<td style="text-align:left">性能时间线</td>
<td style="text-align:left">以一个统一的接口获取由Navigation Timing、Resourcing Timing和User Timing所收集的性能数据。</td>
</tr>
<tr>
<td style="text-align:left">Battery Status</td>
<td style="text-align:left">电池状态</td>
<td style="text-align:left">能够检测当前设备的电池状态，例如是否正在充电、电量等级。可以根据当前电量决定是否显示某些内容，对于移动设备来说非常实用。</td>
</tr>
<tr>
<td style="text-align:left">User Timing</td>
<td style="text-align:left">用户计时</td>
<td style="text-align:left">可以对某段代码、函数进行自定义计时，以了解这段代码的具体运行时间。</td>
</tr>
<tr>
<td style="text-align:left">Beacon</td>
<td style="text-align:left">灯塔</td>
<td style="text-align:left">可以将分析结果或诊断代码发送给服务器，它采用了异步执行的方式，因此不会影响页面中其它代码的运行。</td>
</tr>
<tr>
<td style="text-align:left">Animation Timing</td>
<td style="text-align:left">动画计时</td>
<td style="text-align:left">通过requestAnimationFrame函数让浏览器精通地控制动画的帧数，能够有效地配合显示器的刷新率，提供更平滑的动画效果，减少对CPU和电池的消耗。</td>
</tr>
<tr>
<td style="text-align:left">Resource Hits</td>
<td style="text-align:left">资源提示</td>
<td style="text-align:left">通过html属性指定资源的预加载，例如在浏览相册时能够预先加载下一张图片，加快翻页的显示速度。</td>
</tr>
<tr>
<td style="text-align:left">Frame Timing</td>
<td style="text-align:left">帧计时</td>
<td style="text-align:left">通过一个接口获取与帧相关的性能数据，例如每秒帧数和TTF。</td>
</tr>
<tr>
<td style="text-align:left">Navigation Error Logging</td>
<td style="text-align:left">错误日志记录</td>
<td style="text-align:left">通过一个接口存储及获取与某个文档相关的错误记录。</td>
</tr>
</tbody>
</table>
<h2 id="浏览器支持">浏览器支持</h2><p>下表列举了当前主流浏览器对性能API的支持，其中标注星号的内容并非来自于Web性能工作小组。</p>
<table>
<thead>
<tr>
<th style="text-align:left">规范</th>
<th style="text-align:center">IE</th>
<th style="text-align:center">Firefox</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Safari</th>
<th style="text-align:center">Opera</th>
<th style="text-align:center">iOS Safari</th>
<th style="text-align:center">Android</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Navigation Timing</td>
<td style="text-align:center">9</td>
<td style="text-align:center">31</td>
<td style="text-align:center">全部</td>
<td style="text-align:center">8</td>
<td style="text-align:center">26</td>
<td style="text-align:center">8 (不包括 8.1)</td>
<td style="text-align:center">4.1</td>
</tr>
<tr>
<td style="text-align:left">High Resolution Timing</td>
<td style="text-align:center">10</td>
<td style="text-align:center">31</td>
<td style="text-align:center">全部</td>
<td style="text-align:center">8</td>
<td style="text-align:center">26</td>
<td style="text-align:center">8 (不包括 8.1)</td>
<td style="text-align:center">4.4</td>
</tr>
<tr>
<td style="text-align:left">Page Visibility</td>
<td style="text-align:center">10</td>
<td style="text-align:center">31</td>
<td style="text-align:center">全部</td>
<td style="text-align:center">7</td>
<td style="text-align:center">26</td>
<td style="text-align:center">7.1</td>
<td style="text-align:center">4.4</td>
</tr>
<tr>
<td style="text-align:left">Resource Timing</td>
<td style="text-align:center">10</td>
<td style="text-align:center">34</td>
<td style="text-align:center">全部</td>
<td style="text-align:center">-</td>
<td style="text-align:center">26</td>
<td style="text-align:center">-</td>
<td style="text-align:center">4.4</td>
</tr>
<tr>
<td style="text-align:left">Battery Status*</td>
<td style="text-align:center">-</td>
<td style="text-align:center">31（部分支持）</td>
<td style="text-align:center">38</td>
<td style="text-align:center">-</td>
<td style="text-align:center">26</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">User Timing</td>
<td style="text-align:center">10</td>
<td style="text-align:center">-</td>
<td style="text-align:center">全部</td>
<td style="text-align:center">-</td>
<td style="text-align:center">26</td>
<td style="text-align:center">-</td>
<td style="text-align:center">4.4</td>
</tr>
<tr>
<td style="text-align:left">Beacon</td>
<td style="text-align:center">-</td>
<td style="text-align:center">31</td>
<td style="text-align:center">39</td>
<td style="text-align:center">-</td>
<td style="text-align:center">26</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">Animation Timing</td>
<td style="text-align:center">10</td>
<td style="text-align:center">31</td>
<td style="text-align:center">全部</td>
<td style="text-align:center">6.1</td>
<td style="text-align:center">26</td>
<td style="text-align:center">7.1</td>
<td style="text-align:center">4.4</td>
</tr>
<tr>
<td style="text-align:left">Resource Hints</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">仅限Canary版</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">Frame Timing</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">Navigation Error Logging</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">WebP*</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">全部</td>
<td style="text-align:center">-</td>
<td style="text-align:center">26</td>
<td style="text-align:center">-</td>
<td style="text-align:center">4.1</td>
</tr>
<tr>
<td style="text-align:left">Picture element and srcset attribute *</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">38</td>
<td style="text-align:center">-</td>
<td style="text-align:center">26</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>其中有两个可以帮助我们检测真实用户环境下的页面加载Timing和页面资源加载Timing: <code>Navigation Timing</code>和<code>Resource Timing</code>。这两个API非常有用，可以帮助我们获取页面的Domready时间、onload时间、白屏时间等，以及单个页面资源在从发送请求到获取到rsponse各阶段的性能参数。</p>
<p>使用这两个API时需要在页面完全加载完成之后才能使用，最简单的办法是在window.onload事件中读取各种数据，因为很多值必须在页面完全加载之后才能得出。</p>
<h2 id="Navigation_Timing">Navigation Timing</h2><p><code>Navigation Timing API</code>能够帮助网站开发者检测真实用户数据（RUM），例如带宽、延迟或主页的整体页面加载时间。用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timinhObj = performance.timing;</span><br></pre></td></tr></table></figure>
<p><code>performance.timing</code>返回的是一个<code>PerformanceTiming</code>对象，如下图：</p>
<p><img src="/images/performance/performancetiming01.png" alt="PerformanceTiming"></p>
<p>如果要获得 page load time(页面加载时间)，可以用<code>PerformanceTiming</code>对象中<code>loadEventStart</code>的值减去<code>navigationStart</code>的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt = page.loadEventStart - page.navigationStart;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>PerformanceTiming</code>对象中各属性值的单位均为毫秒数。</p>
<p><code>PerformanceTiming</code>对象包含了各种与浏览器性能有关的时间数据，提供浏览器处理网页各个阶段的耗时，它包含的页面性能属性如下表：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>navigationStart</td>
<td>准备加载新页面的起始时间</td>
</tr>
<tr>
<td>redirectStart</td>
<td>如果发生了HTTP重定向，并且从导航开始，中间的每次重定向，都和当前文档同域的话，就返回开始重定向的timing.fetchStart的值。其他情况，则返回0</td>
</tr>
<tr>
<td>redirectEnd</td>
<td>如果发生了HTTP重定向，并且从导航开始，中间的每次重定向，都和当前文档同域的话，就返回最后一次重定向，接收到最后一个字节数据后的那个时间.其他情况则返回0</td>
</tr>
<tr>
<td>fetchStart</td>
<td>如果一个新的资源获取被发起，则 fetchStart必须返回用户代理开始检查其相关缓存的那个时间，其他情况则返回开始获取该资源的时间</td>
</tr>
<tr>
<td>domainLookupStart</td>
<td>返回用户代理对当前文档所属域进行DNS查询开始的时间。如果此请求没有DNS查询过程，如长连接，资源cache,甚至是本地资源等。 那么就返回 fetchStart的值</td>
</tr>
<tr>
<td>domainLookupEnd</td>
<td>返回用户代理对结束对当前文档所属域进行DNS查询的时间。如果此请求没有DNS查询过程，如长连接，资源cache，甚至是本地资源等。那么就返回 fetchStart的值</td>
</tr>
<tr>
<td>connectStart</td>
<td>返回用户代理向服务器服务器请求文档，开始建立连接的那个时间，如果此连接是一个长连接，又或者直接从缓存中获取资源（即没有与服务器建立连接）。则返回domainLookupEnd的值</td>
</tr>
<tr>
<td>(secureConnectionStart)</td>
<td>可选特性。用户代理如果没有对应的东东，就要把这个设置为undefined。如果有这个东东，并且是HTTPS协议，那么就要返回开始SSL握手的那个时间。 如果不是HTTPS， 那么就返回0</td>
</tr>
<tr>
<td>connectEnd</td>
<td>返回用户代理向服务器服务器请求文档，建立连接成功后的那个时间，如果此连接是一个长连接，又或者直接从缓存中获取资源（即没有与服务器建立连接）。则返回domainLookupEnd的值</td>
</tr>
<tr>
<td>requestStart</td>
<td>返回从服务器、缓存、本地资源等，开始请求文档的时间</td>
</tr>
<tr>
<td>responseStart</td>
<td>返回用户代理从服务器、缓存、本地资源中，接收到第一个字节数据的时间</td>
</tr>
<tr>
<td>responseEnd</td>
<td>返回用户代理接收到最后一个字符的时间，和当前连接被关闭的时间中，更早的那个。同样，文档可能来自服务器、缓存、或本地资源</td>
</tr>
<tr>
<td>domLoading</td>
<td>返回用户代理把其文档的 “current document readiness” 设置为 “loading”的时候</td>
</tr>
<tr>
<td>domInteractive</td>
<td>返回用户代理把其文档的 “current document readiness” 设置为 “interactive”的时候.</td>
</tr>
<tr>
<td>domContentLoadedEventStart</td>
<td>返回文档发生 DOMContentLoaded事件的时间</td>
</tr>
<tr>
<td>domContentLoadedEventEnd</td>
<td>文档的DOMContentLoaded 事件的结束时间</td>
</tr>
<tr>
<td>domComplete</td>
<td>返回用户代理把其文档的 “current document readiness” 设置为 “complete”的时候</td>
</tr>
<tr>
<td>loadEventStart</td>
<td>文档触发load事件的时间。如果load事件没有触发，那么该接口就返回0</td>
</tr>
<tr>
<td>loadEventEnd</td>
<td>文档触发load事件结束后的时间。如果load事件没有触发，那么该接口就返回0</td>
</tr>
</tbody>
</table>
<p>一般来说，我们需要获取到的页面性能参数包括：<strong>DNS查询耗时、TCP链接耗时、request请求耗时、解析dom树耗时、白屏时间、domready时间、onload时间</strong>等，而这些参数是通过上面的<code>performance.timing</code>各个属性的差值组成的，计算方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DNS查询耗时 ：domainLookupEnd - domainLookupStart</span><br><span class="line">TCP链接耗时 ：connectEnd - connectStart</span><br><span class="line">request请求耗时 ：responseEnd - responseStart</span><br><span class="line">解析dom树耗时 ： domComplete - domInteractive</span><br><span class="line">白屏时间 ：responseStart - navigationStart</span><br><span class="line">domready时间 ：domContentLoadedEventEnd - navigationStart</span><br><span class="line">onload时间 ：loadEventEnd - navigationStart</span><br></pre></td></tr></table></figure>
<p><code>Navigation Timing</code>的目的是用于分析页面整体性能指标。如果要获取个别资源（例如JS、图片）的性能指标，就需要使用<code>Resource Timing API</code>。</p>
<h2 id="Resource_Timing">Resource Timing</h2><p>浏览器获取网页时，会对网页中每一个静态资源（脚本文件、样式表、图片文件等等）发出一个HTTP请求。<code>Resource Timing</code>可以获取到单个静态资源从开始发出请求到获取响应之间各个阶段的Timing。用法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resourcesObj = performance.getEntries();</span><br></pre></td></tr></table></figure>
<p><code>Resource Timing</code>返回的是一个对象数组，数组的每一个项都是一个对象，这个对象中包含了当前静态资源的加载Timing，如下图：</p>
<p><img src="/images/performance/performancetiming02.png" alt="PerformanceTiming"></p>
<p>我们可以根据数组的长度获取到页面中静态资源的数量，然后通过数组的每一项分析单个静态资源的请求状态。</p>
<p><code>performance</code>中还有一些性能API尚未成为W3C标准（如第一张图中的工作进度），有的处于编辑草案阶段，有的处于工作草案阶段，当这些API逐渐成为推荐标准以后，一定会对我们进行前端性能监控带来很大的便利，我们也可以通过这些API很方便地直接从页面中获取到我们希望得到的性能信息。</p>
<h2 id="相关资源">相关资源</h2><p><a href="http://javascript.ruanyifeng.com/bom/performance.html" target="_blank" rel="external">performance API</a></p>
<p><a href="https://github.com/fredshare/blog/issues/5" target="_blank" rel="external">window.performance 详解</a></p>
<p><a href="http://www.cnblogs.com/mrsunny/archive/2012/09/04/2670727.html" target="_blank" rel="external">使用简洁的 Navigation Timing API 测试网页加载速度（不完全译文）</a></p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/performance/" class="post__tag__link">performance</a></li><li class="post__tag__item"><a href="/tags/前端性能/" class="post__tag__link">前端性能</a></li><li class="post__tag__item"><a href="/tags/原创/" class="post__tag__link">原创</a></li></ul><a class="post__foot-link u-fr"></a></footer></article></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2016 Horve<bdi> Theme by <a href="https://github.com/andforce/hexo-theme-andforce" >andforce</a></bdi></div><menu class="page-menu u-fr"><li class="page-menu__item"><span title="Previous" class="page-menu__link icon-arrow-left page-menu__link--disabled"></span></li><li class="page-menu__item"><span title="Next" class="page-menu__link icon-arrow-right page-menu__link--disabled"></span></li></menu></footer></body></html>